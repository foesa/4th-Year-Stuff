\chapter{Executive Summary}

\section{Executive Summary}

During my time at HubSpot I was assigned 2 major tasks that I worked on over the course of the few months of my placement. To get me started and introduced to the tech stack at HubSpot, I first started with an onboarding project that enabled me to become somewhat familiar with the stack by using many of the major tools and languages that are commonly used in HubSpot. This introductory project introduced us to the major programming languages in HubSpot, some of the predominant patterns used at HubSpot such as the Builder pattern and how to use things like annotations and dependency injection. There was also an aspect of the onboarding that required us to build a react app and create a front end that plugged into a simple backend we had created also. This wasn't a part I spent too much on as I was on a predominantly back-end team.\newline \\ Once I had completed this, I was introduced to my first major task, building a multicurrency consumer to make currency fields editable in the UI. This was part of a wider set of changes to multiple repositories my team owned to standardise fields so we could make the prices of items and such editable in the UI, which was a major pain point for our customers. This change was quite large in size and required multiple pull requests and a lot of code to be written to get it going. For this change to be made, some endpoints had to be written alongside a brand new kafka consumer. This task was what I spent the majority of my time at the internship working on. \newline \\The other task I worked on during my time at HubSpot was a change to users using Shopify as part of a company wide initiative to make us GDPR compliant. In order to do this, a new EU Hublet was made as previously all data was routed to the US and handled there but under GDPR, users have to be allowed to both chose where their data is sent and where it's stored. To make us GDPR compliant, I had to change the webhooks for all users using Shopify to point to a load balancer that would then determine where the data should be routed. To do this I had to write a backfill job that performed some major operations on the database and changed the data in there. This change was fairly straight forward but there was a bug that made it to production that caused all users webhooks to be broken. This bug was fixed and the task was re-run but there was a period of down time that took a period of remidiation to fix and retrieve all missed data that couldn't be synced while the webhooks weren't active.